BIO：同步并阻塞
NIO：同步非阻塞
AIO：异步非阻塞
	
linux内存分为内核区和用户区
read是一个阻塞函数，当调用read时程序挂起，等待文件描述符的读就绪：
	硬件读取文件数据到文件描述符指向的结构体的缓冲区
	结构体的缓冲区传输到用户区------》完成一次IO
	
阻塞IO

非阻塞IO：
	调用read，马上返回一个错误码，就可以做其他的了	轮询：
		消耗很多用户区CPU
		
IO复用：
	如果轮询是内核区发起的，就有效率的提升：
		如果有条件，就会操作
		select poll 句柄有限1024	epoll增强
		
信号驱动：
	不会进行轮询，也不会阻塞，而是等待某一个时刻数据准备好了，内核会通知启动io操作，将数据从内核区复制到用户区
	
异步io:
	信号驱动的升级版本：
		等内核完成整个操作之后再通过应用程序，这整个过程包括了硬件读取数据到内核结构体的缓冲区中，以及缓冲区的数据
		复制到用户区中，这整个过程进程都不会阻塞
	
