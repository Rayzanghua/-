介绍：
	线程运行程序控制流的多重分支同时存在于一个进程。他们共享进程范围内的资源，比如内存，但是每一个线程有其自己的程序计数器・stack・和本地变量
	优点：
		降低开发和维护的开销，并能够提高复杂应用的性能。
		通过把异步的工作流程转为普遍存在的顺序流程，模拟人类工作和交互更加容易了。
		把复杂，难以理解的代码转化为简洁的代码，易于维护
		
	@NotThreadSafe	@ThreadSafe	@Immutable	详见：附录A
	
	活跃度失败：
		死锁	饥饿	活锁
		
	性能：
		上下文切换	造成开销
		清空或锁定内存和高速缓存，并在共享内存的总线上创建同步通信	造成开销
		
	定时器：
		TImer来调度一些任务	通常确保任务本身是线程安全的	
	Servlets and JavaServer Pages：
		Servlets应该是线程安全的	包括JSP，Servlet Filter以及储存在ServeletContext和HttpSession
	远程方法调用RMI：
		pass
		
	线程3种修复：
		不要跨线程共享变量
		是状态变为不可以变的
		任何时候访问都要使用同步
		
	无状态的Servlet：
		多数servelt都是无状态的，不包含域也没有引用，所以无状态对象是线程安全的
		
	惰性初始化：
		懒汉模式	就是线程不安全的
		
	复合操作：
		读写改为一组复合操作
		如果操作A和B，从A的角度看，B要么全部执行完，要么不执行，这样子就互为原子操作
		
	线程安全性的定义：
		无论是多线程中的时序或交替操作，都要保证不破坏那些不变约束。
		
		为了保护状态的一致性，要在单一的原子从操作中更新相关联的状态变量
		
	重进入：
		可以避免死锁
		
		
		--------------------------chapter3----------------------------------
		
可见性：
	重排序
	
	最低的安全性：
		保证在某个线程下是个真实的数据	eg:没有volatile的float与double就不是，他们是64位的会分为两个32位
		
	volatile	同步弱形式：
		不会缓存在寄存器，所以读一个volatile类型的变量时，总会返回某个线程写入的最新值
		然而访问volatile变量的操作不会加锁，也不会引起线程的阻塞，这使得volatile相对于sychronized而言，只是轻量级的同步机制
		
		满足一下条件才能使用volatile：
			写入变量时不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值
			变量不需要与其他状态变量共同参与不变约束；
			而且，访问变量时，没有其他的原因需要加锁
		
	发布与逸出：
		发布是使他能够被当前范围之外的代码所用
		溢出是一个对象还未准备好就将他发布
		不要让this在构造期间逸出
		
	Ad-hoc线程限制：
		非常容易出错	限制固有的易损性
		
	栈限制：
		是线程限制的一种特例，只有通过本地变量才可以触及对象，
		仅存在于执行线程栈。但是与ThreadLocal与区别，与ad-hoc相比易于维护，更加健壮
		
	ThreadLocal：
		提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝。
		所以get总是由当前执行线程通过set设置最新的值。
		与线程相关的值存储在线程对象自身中，线程终止后，这些值会被垃圾回收
		
	不可变对象：
		他的状态不能再创建后再被修改
		所有域都是final类型；并且
		他被正确的创建（期间没有发生this引用的逸出）
		
	共享对象的一些策略：
		线程限制：
		共享只读	shared read-only：
		共享线程安全	shared-safe：是一个线程安全的对象
		被守护的	guarded：只能通过特定的锁来访问。
		
		--------------------------------chapter4------------------------------
		
设计线程安全类的过程三个要素：
	确定对象状态是由哪些变量构成的
	确定限制状态变量的不变约束
	制定一个管理并发访问对象状态的策略
	
		同步策略：
			定义了对象如何协调对其状态的访问，并且不会违背他的不变约束。
			保证了开发者和维护者可以分析并维护类，应该将类的同步策略写入文档
			
servletContext：
	线程安全的对象
	
使用私有锁对象，而不是对象的内部锁的好处：
	私有的锁对象可以封装锁，这样客户代码无法得到它
	
@GuardeBy	线程的文档
-------------------------------chapter5---------------------------------------------

jdk6.0：
	加入了ConcurrentSkipListMap和ConcurrentSkipListSet，来作为同步的
	SortedMap和SortedSet的并发替代品
	Deque:	ArrayDeque LinedBlockingDeque

jdk5.0：	
	扩展了Queue和BlockingQueue	ConcurrentHashMap	
	CopyOnWriteArrayList是List相应的实现
	
ConcurrentHashMap：
	分离锁
	
	返回的迭代器具有弱一致性。指的是：
		允许容器可以并发修改，当迭代器被创建时，他会遍历已有的所有元素，并且感应到迭代器创建后，对容器的修改
		
	没有实现独占的访问加锁，在Hashtable和synchronizedMap中实现了
	意味着如果要实现更多的原子操作 就不能使用该容器了
	
CopyOnWriteArrayList:
	相当于写锁，写入时候复制，读多写少的时候
阻塞队列：
	BlockingQueue的实现：
		LinkedBlockingQueue	ArrayBlockingQueue	都是FIFO队列
		PriorityBlockingQueue可以比较元素本身的自然顺序，如果他们实现了Comparable，也可以用Comparator进行排序
		SynchronousQueue没有储存空间
		
Synchronizer(#####):
	信号量	semaphore	关卡	barrier 	闭锁	latch
		闭锁：
			可以延迟线程的进度知道线程到达终止状态
		FutureTask	同样可以作为闭锁：
			依赖与任务的状态
			等价于一个可以携带结果的Runnable
			Executor框架利用FutureTask来完成异步任务
		关卡：
			类似于闭锁，不同点在于：
				所有线程必须同时到达关卡点，才能继续处理。
				闭锁等待的是事件，关卡等待的是其他线程
				
				---------------------------------------chapter6-------------------------------------

无限制创建线程的缺点：
	线程生命周期的开销
	资源消耗量
	稳定性：
		一旦超出，可能会遇到OutOfMemoryError

请优先考虑使用Executor代替Thread
		
Executor框架	异步的执行任务：
	newFixedThreadPool：
		创建一个定长的线程池，如果某个线程出现一个Exception，线程池会补充一个新的线程
	newCachedThreadPool：
		创建一个可缓存的线程池，如果长度超过当前处理的需要，可以灵活的回收空闲的线程，
		当需求增加时，可以灵活的添加新的线程，而不会对池的长度做任何改变
	newSingleThreadExecutor：
		创建一个单线程化的executor，如果出现异常会有另一个线程取代
	newScheduledThreadPool：
		创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer
			但是Timer会出现线程泄露，由于不能处理线程抛出的异常
			Timer会造成混乱，如果两次的时间不一样
		
	ExecutorService的生命周期：
	
	Future执行的任务的生命周期：
		创建，提交，开始，完成
		不可以后退
		
	可携带结果的任务：
		Callable和Future
		
	
Future:
	可以用来接收ExecutorService的submit返回Future对象，通过get来获得
		
		
	-------------------------------chapter7------------------------------------------------------
	
任务取消：
		当外部代码能够在活动自然完成之前，把他更改为完成状态，那么这个活动称为可取消的
		用户的取消
		限时活动
		应用程序事件
		错误
		关闭
		
interrupt：
	中断目标线程，并且isInterupted返回目标线程的中断状态
	静态的interrupt方法名不理想，仅能够清除当前线程的中断状态，并返回它之前的值；这是清除状态唯一的方法
	
中断策略：
	捕获这个异常
	
Executor 接口	exe方法：
ExetroService	接口	submit方法：同样与exe类似	但是会返回一个Future对象
		
除非你拥有某个线程，不然不应该控制某个线程	中断它，改变优先级等等
		
	------------------------------------chapter8****---------------------------------------------
	
Exectors	框架返回Exector接口实现的线程池

ThreadPoolExecutor允许你提供一个BlockingQueue来持有等待执行的任务。：
	任务排队有3种基本方法：
		无限队列，有限队列和同步移交
		
	newFixedThreadPool	newSingleThreadExecutor：
		默认使用的是一个无限的LinkedBlockingQueue
		
		有限队列：
			ArrayBlockingQueue	LinkedBlockingQueue	PriorityBlockingQueue
			
	对于庞大或者无限的池，SynchronousQueue可以完全绕开队列，将任务直接从生产者移交给工作者线程：
		SynchronousQueue并不是一个真正的队列，而是一种管理直接在线程间移交信息的机制，
		为了把一个元素放到SynchronousQueue中，必须有另一个线程正在等待接受移交的任务。
		如果没有这样一个线程，只要当前池的大小还小于最大值，ThreadPoolExecutor就会创建一个新的线程；
		否则根据饱和策略，任务会被拒绝。使用直接提交会更加高效，因为任务不必先放置队列中，就可以立即交由即将执行的线程处理
		，然后在让工作者线程从队列中获取它。只有当池是无限的，或者可以接受任务被拒绝，SynchronousQueue才是一个有实际价值的选择
		newCachedThreadPool 就使用了
		
	newCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，他说Executor的一个很好的默认选择
	
饱和策略：
	JDK几种不同的RejectExecutionHandler实现：
		AbortPolicy,CallerRunPolicy,DiscardPolicy,DiscardOlddestPolicy
		
	遗弃	默认放弃这个任务
	遗弃最旧的
	调用者运行
	
谜题：
	
	-----------------------------------chapter10======================================
	
饥饿：
	当线程访问它所需要的资源时却被永久拒绝，以至于不能再继续进行，这样就发生了饥饿
	
活锁：
	线程活跃度失败的另一种形式，尽管没有被堵塞，线程任然不能继续进行，因为他不断重试相同的操作
	
	-----------------------------------chapter11------------------------------------------------
	
CurrentHashMap：
	内部Hash通过%16	处理这16个锁	而不是每个hash一个锁
	----------------------------------------chapter12------------------------------------------------
	
吞吐量：
	在一个并发任务集里，已完成任务所占的比例
响应性：
	从请求到完成一些动作之间的延迟
可伸缩性：
	增加更多的资源，就能提高吞吐量

	---------------------------------------chapter13----------------------------------------------------
	
Lock:提供了无条件的，可轮询的，定时的，可中断的锁获取操作，所有加锁和解锁的方法都是显示的

锁一定要在finally语句中释放

lock接口：
	trylock两种方法	
	lockInterruptibly方法
	
闯入锁比公平锁性能好的原因：
	线程A持有一个锁，线程B请求该锁。B被挂起。当A释放锁，B重新开始。此时，C若请求该锁，C得到了很好的机会获得这个锁
	使用它，甚至可能在B被唤醒前就释放该锁了
	
ReentranLock与synchronize：
	ReentranLock需要在finally释放，但是性能在jdk6.0之后大大提升了
	
	-----------------------------------------------chapter14-------------------------------------------------------
	
当使用条件等待时：
	永远设置一个条件谓词，一些对象状态的测试，线程执行前必须满足它
	永远在调用wait前测试条件谓词，并且从wait中返回后再次测试
	原因在循环中调用wait
	确保构成条件的谓词状态变量被锁保护，而这个锁正是与条件队列相关联的
	当调用wait，notify或者notifyall时，要持有与条件队列相关联的锁，并且
	在检查条件谓词之后，开始执行被保护的逻辑之前，不要释放锁
	
活跃度失败 	丢失的信号：
	如果线程A通知了一个条件队列，线程B随后在同一个队列上等待，那么线程B不会立即被唤醒，需要另一个通知在唤醒他

	只有同时满足下面条件才能使用单一notify：
		相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回后执行相同的逻辑
		并且，一进一出，一个队条件变量的通知，最多只激活一个线程执行
		
Condition：
	
Synchronizer：

AbstractQueuedSynchrogazer：

---------------------------------------------chapter15-------------------------------------------------------------

独占锁是一项悲观的技术：
	它假设最坏情况，并且会通过获得正确的锁来避免其他线程的打扰，直到做出保证才能继续进行
	
	通常另外一种选择更有效--乐观的解决方法
	
CAS：
	3个操作数
	内存位置V
	旧的预期值A
	新的值B
	
	当且仅当V复合旧预期值A时，CAS用新值B原子化的更新V的值；否则他什么都不做。
	在任何一种情况下，都会返回V的真实值
	CAS是一项乐观技术
	
一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法成为非阻塞算法
如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由算法

ABA问题：
	正常的CAS中
		A转为B如果失败就回退，但是ABA中需要记录B转为A或者需要什么步骤，就会有ABA问题
	算法中误用比较并交换而引起的反常现象，即A转为B再转为A
	
------------------------------------------chapter16-----------------------------------------------------------------------
重排序：
	是JVM在单线程中的优化
	但是在多线程当中让程序的行为变得不可预期
	
当一个变量被多个线程都，且至少被一个线程写入时，如果读写操作并未依照happens-before排序，就会产生数据竞争
一个正确的同步程序是没有数据竞争的程序；正确的同步会表现出顺序的一致性，

happens-before：
	程序次序法则：
		线程中的每个动作A都happens-before与线程中的每一个动作B
	监视器锁法则：
	volatile变量法则：
	程序启动法则：
	程序终结法则
	中断法则：
	
双检查锁	DCL：
	最糟糕的情况对象可以被观察到，但却处于无效或错误的状态：
		JMM后序的修订把resource声明为volatile类型
		
final可以抑制重排序

	
	
	
