




Integer 中可以进制转换:
	Integer.toHexString()	转为16进制字符串
	Integer.parseUnsignedInt("", 4);	将数字用后面的进制表示
	(char)122		(int)'a'		


boolea	byte short int long float double char 





--------------------------------------chapter2---------------------------------------------
程序计数器：
	是一块较小的内存空间，看作是当前线程锁执行的字节码的行号指示器。
	在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
	分支，循环，跳转，异常处理，线程回复等基础功能都需要依赖这个计数器来完成
	
returnAddress	原始类型：
	会被Java虚拟机的 jsr ret jsr_w指令所使用。
	指向一条虚拟机指令的操作码，与其他类型不同在java语言中不存在相应的类型，
	无法再程序运行期间更改returnAddress类型的值
	
boolean	编译之后使用java虚拟机的int数据类型来代替

虚拟机三种引用类型：
	类类型	数组类型	接口类型
	
PC寄存器：
	Program Counter		：
		在任意时刻一条java虚拟机线程只会执行一个方法的代码。如果方法不是native的，
		拿pc寄存器就保存正在执行的字节码指令的地址，如果该方法是native的，值是undefined
		pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个平台相关的本地指针的值
		
java虚拟机栈：
	就是用于存储局部变量与一些过程结果的地方
	这个栈与线程同时创建，用于储存栈帧。除了出栈入栈，不会再受其他因素影响，所以栈可以在堆中分配，
	栈使用的内存不需要保证是连续的；
	允许栈实现成固定大小或者是更具计算动态扩展和收缩；
	如果采取固定大小的java虚拟节栈设计，每一条的线程的java虚拟机栈容量应当在创建的时候独立的选定。
	java虚拟机实现应当提供给程序员或者最终用户调节栈初始容量的手段，对可以扩展和收缩的虚拟机栈俩说，应当提供最大，最小容量的手段：
		如果栈容量超过允许最大时，抛出Stack OverflowError异常
		如果可以动态扩展，但是无法申请足够的内存完成扩展，抛出OutOfMemoryError
		
Java堆：
	可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域，在虚拟机启动的时候就被创建：
		容量可以是固定大小的，也可以动态扩展，也可以自动收缩。不保证堆中内存是连续的：
			OutOfMemoryError
			
方法区：
	提供个条线程共享运行时内存区域。
	储存了每一个类的结构信息，例如运行时常量池，字段和方法数据，构造函数和普通方法的字节码内容，
	还包括一些类，实例，接口初始化用到的特殊方法
	在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现GC
	方法区的容量是固定大小的，也可以随着程序的执行需求动态扩展，不会自动收缩。
	方法区在实际内存空间中可以是不连续的		OutOfMemoryError
	
运行时常量池：
	在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来了		OutOfMemoryError
	
本地方法栈：
	java虚拟机实现可能会使用到传统的栈来支持native方法，这个栈就是本地方法栈。
	如果java虚拟机不支持native方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈，如果支持，
	一般会再线程创建的时候按线程分配：
		OutOfMemoryError
		Stack OverflowError
		
栈帧：
	局部变量表和操作数栈的容量是在编译期确定，通过方法的Code属性保存及提供给栈帧使用。
	
	局部变量表：
		每个栈帧内部都包含一组称为局部变量表的变量列表
		栈帧中局部变量表长度编译期决定，并且储存于类和接口的二进制之中，通过方法的Code属性保存及提供给栈帧使用
		一个局部变量可以保存一个类型为 boolean、 byte、 char、 short、 float、 reference
		和 returnAddress 的数据，两个局部变量可以保存一个类型为 long 和 double 的数据
		
	操作数栈：
		每一个栈内部都包含一个操作数栈的后进先出栈。编译期确定，并且储存于类和接口的二进制表示之中，既通过方法的Code
		属性保存及提供给栈帧使用
		操作数栈所属的栈帧在刚刚创建的时候，操作数栈是空的。Java虚拟机提供一些字节码指令从局部变量表或者对象实例的字段中
		复制常量或变量值到操作数栈中，也可以取走。方法调用时候，操作数栈也用来准备调用方法的的参数和接受的结果
		
字节码：
	如果操作数的长度超过了一个字节，以Big-Endian顺序储存--及高位在前的字节序
	
运算指令：
	所有NaN值为操作数的算术操作，结果都会返回NaN
	
同步：
	虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程来支持的
	方法同步是隐式的，无需字节码指令来控制的，它实现在方法调用和返回操作之中。。
	虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志区分一个方法是否同步。
	当方法调用时，调用指令将会检查ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程先持有管程，
	然后在执行方法，最后方法完成释放管程。持有期间，任何其他线程无法再获得同一个管程
		
----------------------------------chapter3------------------------------------------
iconst 0表示吧int型的0值压入操作数栈，这样，iconst 0 不需要专门为入栈操作保存一个立即操作数的值

----------------------------------chapter5--------------------------------------------





