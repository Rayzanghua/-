字符的混用：
	l,o,O不要与数字混用；如果需要加上注释
	
如果是常量，那么应该保持不变，不要与随机数混用：
	常量必须在编译期间就该确定值，不应该在运行期间更改
		public static final int RAND_CONST=new Random().nextInt();

三元运算符应该保证返回的两个数类型一致，不然会进行转换的
	String s1=String.valueOf(i<100?90:100.0);
	
重载方法是在编译期间就确定了的，应该慎用重载，尤其是参数有联系的时候，比如变长参数，参数具有父子关系

count++陷阱：
	for(int i=0;i<10;i++){count=count++;}	count依然是0
		JVM:JVM把count拷贝到临时变量区间；count+1；返回临时变量区间的值，依然是0；赋值给count，重置为0
		
goto语句陷阱：
	goto语句已经不使用了，但是可能还会遇到类似于xx:xx 的陷阱

慎用静态导入：
	同时如果要变更一个静态导入的方法，不应该在奔雷中覆盖，而在原始类中重构
	
序列化：
	显示声明UID；
		可以避免编译期间复杂的计算；
		同时也可以偶尔向上兼容一下；
	反序列化不会在构造函数中赋值；
	如果final修饰的属性不是基本类型也不会赋值或者是一个方法的返回值；
	序列化不会给transient和static序列化；
	
一些易变的脚本可以通过脚本语言编写，然后通过java内置的平台来运行

java也能够支持动态编译jdk1.6之后：
	但是debug很困难；
	不要在高性能的项目中使用；
	记录动态编译过程，考虑安全问题；
	
常用instanceof判断类型

assert断言
	不是特别清楚；是个关键字
	
发布项目时：
	整体war发布，还是由于final的原因，替换class没有效果
	
根据不同的项目，慎重选择不同的舍入方式，从而减少算法损失

包装类型时，应该做null判断；比较大小时应该使用的是基本类型；整型池的概念；基本类型优先考虑

构造函数应该简化，同时不要声明初始化其他的类

构造代码块是用于给多个构造函数使用的早期

让工具类不可实例化

浅拷贝是java默认的，我们不应该直接使用

使用equals之前null判断，getClass(建议)或者instanceof判断


	




